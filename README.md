# Error-Finding-Algorithms-HammingCod




Введение.
Цель: Ознакомится с алгоритмами поиска ошибок при передачи текста по информационному каналу и реализовать их.
Задача:Реализовать Windows Form проект на c#. 
Реализовано: код Хэмминга, добавление бита четности, собственный алгоритм «Контрольная сумма».
Аналитическая часть.

История создание кода Хэмминга.
 Первая работа по теории кодирования была опубликована известным ученым Ричардом Уэсли Хэммингом в 1950 году. Привело его к этой работе следующее: после окончания университета он занимался тем, что сейчас бы назвали численными методами, и работал сначала в Лос-Аламосе над Манхэттенским проектом, то есть над созданием ядерной бомбы, а потом почти сразу, в 1946 году, перешел в Bell Labs. Это та великая лаборатория, в которой было сделано, наверное, самое большое количество открытий второй половины XX века. Там он продолжал заниматься численными методами, решать уравнения на первых вычислительных машинах.
Вычислительные машины были огромными, ненадежными, потому что на лампах, и для их охлаждения требовалось большое количество воды, и тем не менее они часто сбоили. Программисты того времени, чтобы бороться со сбоями, делили задачу на этапы, и после каждого этапа программа должна была записать или распечатать результаты. Тогда задачи были простенькие по теперешним понятиям, в основном счет.
Зачем это делалось? Так как эти компьютеры были ненадежными, у них было такое устройство, как сигнал тревоги. Когда работа шла неверно, когда они обнаруживали ошибку, то звучал сигнал тревоги, и работа прекращалась. Соответственно, человек мог с этого места посмотреть назад, какое было первое от этого места правильно посчитанное значение, и продолжать счет дальше. Хэмминг оставлял свою работу на выходные и уходил спокойно отдыхать, а приходя, обнаруживал, что машина работала впустую, потому что в некий момент происходила ошибка, но никого не было, его не было, чтобы остановить. Значит, все его труды пропадали даром. Тогда у него возникла совершенно естественная даже не идея, а вопрос: если машина умеет обнаруживать ошибки, почему бы не научить ее, чтобы она их исправляла?
Что пришло в голову Хэммингу? Он подумал, почему, собственно, проверять все значения? Может, одного проверочного символа недостаточно? Может быть, добавить не один, а два, три, четыре - столько, сколько понадобится, и исправлять?
Так и возник, наверное, самый известный код, так называемый (7,4) код Хемминга. 4 означает, что мы будем защищать от ошибок 4 бита информации, а 7 - что для этого мы к 4 информационным битам добавим 3 проверочных. Итого всего получается 7 бит.

Реализация кода Хэмминга
Подготовка.
Допустим, у нас есть сообщение «0100010000111101», которое необходимо передать без ошибок.
Далее нам необходимо вставить контрольные биты. Они вставляются в строго определённых местах — это позиции с номерами, равными степеням двойки. В нашем случае (при длине информационного слова в 16 бит) это будут позиции 1, 2, 4, 8, 16. Соответственно, у нас получилось 5 контрольных бит (взяты в скобки):

Было:
0100010000111101
Стало:
(0)(0)0(0)100(0)0100001(0)11101
Таким образом, длина всего сообщения увеличилась на 5 бит. До вычисления самих контрольных бит, мы присвоили им значение «0».
Вычисление контрольных бит.
Теперь необходимо вычислить значение каждого контрольного бита. Значение каждого контрольного бита зависит от значений информационных бит, но не от всех, а только от тех, которые этот контрольных бит контролирует. Для того, чтобы понять, за какие биты отвечает каждых контрольный бит необходимо понять очень простую закономерность: контрольный бит с номером N контролирует все последующие N бит через каждые N бит, начиная с позиции N.
 
Здесь знаком «X» обозначены те биты, которые контролирует контрольный бит, номер которого справа. То есть, к примеру, бит номер 12 контролируется битами с номерами 4 и 8. Ясно, что чтобы узнать какими битами контролируется бит с номером N надо просто разложить N по степеням двойки. 

Но как же вычислить значение каждого контрольного бита? Делается это очень просто: берём каждый контрольный бит и смотрим сколько среди контролируемых им битов единиц, получаем некоторое целое число и, если оно чётное, то ставим ноль, в противном случае ставим единицу. Вот и всё! Можно конечно и наоборот, если число чётное, то ставим единицу, в противном случае, ставим 0. Главное, чтобы в «кодирующей» и «декодирующей» частях алгоритм был одинаков. (Мы будем применять первый вариант).
Высчитав контрольные биты для нашего информационного слова получаем следующее: 
Было:
(0)(0)0(0)100(0)0100001(0)11101
Стало:
(1)(0)0(1)100(0)0100001(0)11101

Декодирование и исправление ошибок.
Теперь, допустим, мы получили закодированное первой частью алгоритма сообщение, но оно пришло к нас с ошибкой. К примеру мы получили такое (11-ый бит передался неправильно): 
(1)(0)0(1)100(0)01*1*0001(0)11101
Вся вторая часть алгоритма заключается в том, что необходимо заново вычислить все контрольные биты (так же как и в первой части) и сравнить их с контрольными битами, которые мы получили. Так, посчитав контрольные биты с неправильным 11-ым битом мы получим такую картину: 
(0)(1)0(1)100(1)01*1*0001(0)11101
Как мы видим, контрольные биты под номерами: 1, 2, 8 не совпадают с такими же контрольными битами, которые мы получили. Теперь просто сложив номера позиций неправильных контрольных бит (1 + 2 + 8 = 11) мы получаем позицию ошибочного бита. Теперь просто инвертировав его и отбросив контрольные биты, мы получим исходное сообщение в первозданном виде! Абсолютно аналогично поступаем со второй частью сообщения
Вывод.
С помощью кода Хэмминга мы можем не только находить ошибку но и исправлять ее.
Бит четности.
В вычислительной технике и сетях передачи данных би́том чётности называют контрольный бит, принимающий значения '0' или '1' и служащий для проверки общей чётности двоичного числа (чётностиколичества единичных битов в числе).
Примеры
Бит чётности или контрольный разряд формируется при выполнении операции «ИсключаюшееИЛИ» поразрядно.  Рассмотрим схему, использующую девятибитные кодовые слова, состоящие из восьми битданных, за которыми следует бит чётности.
Число 10111101 содержит 6 '1' битов. Бит чётности будет 0, получаем кодовое слово 101111010.
Число 01110011 содержит 5 '1' битов.
Бит чётности будет 1, получаем кодовое слово 011100111.
Число 00000000 не содержит '1' битов. Бит чётности будет 0, получаем кодовое слово 000000000.
Пустой или несуществующий поток битов также имеет ноль единичных битов, поэтому бит чётности будет 0.
Вывод.
То есть с помощью бита четности, мы можем проверить была ли совершена ошибка при передаче данных.

Мой собственный алгоритм или алгоритм контрольной суммы.
Допустим у нас есть сообщение «001», которое нам нужно передать, оно будет размешаться в некотором блоке.
 
Но за нахождение в также у блока присутствует «стоимость за нахождение в нем» , допустим блок[0] = 2 , блок [1] = 3 и так далее . Блок[i] = 2+i;
 
Но так же у элементов находящихся в блок присутствует некоторая стоимость.
У нуля это единица, у единицы это двойка.
 
И путем перемножения мы получаем «контрольную сумму» данного сообщения в данном случаи = (1*2) + (1*3) + (2*4) = 13.
Плюсы и минусы алгоритма.
  Плюсы - достаточно легкая и понятная реализация, при многократном использовании можно создать «словарь» в который записывается контрольная сумма и полученное сообщение, то есть когда в нашем словаре будет достаточно данных мы можем восстанавливать сообщение по контрольной сумме.
Минусы - непонятно как лучше отправлять контрольную либо отдельным сообщением, либо вместе с сообщением, непонятно как лучше переводить сумму в двоичную систему или оставлять в десятичной.
Выводы.
Алгоритм не достаточно хорош, но работает, да и ладно.
Проектная часть.
Функционал 
Программа определяет была ли совершена ошибка, при передаче данных.

Архитектура приложения
Программа состоит из двух частей: из Интерфейса Windows Forms и классов в которых находятся сами алгоритмы.
Диаграмма классов

  
Реализация проекта 
Интерфейс программы:
Код Хэмминга:
 
Бит четности
 
Контрольная сумма:
 
Так же в приложении присутствуют обработчики ошибок 
 
 
Среда разработки:
Microsoft Visual Studio
Инструменты:
C# + .NET

Тестирование
Для автоматического тестирования я добавил в проект UnitTestProject.
Результаты тестов:
 

Заключение
В данной курсовой работе я реализовал 3 алгоритма поиска ошибок при передаче текста, также я получил представление о том, что такое самокорректирующийся код, изучил алгоритм кодирования и декодирования кодом Хэмминга
Проект был успешно протестирован. 


Источники
Код Хэмминга    https://habr.com/post/140611/
Бит четности  https://ru.wikipedia.org/wiki/Бит_чётности
М.Н.Аршинов, Л.Е.Садовский. КОДЫ И МАТЕМАТИКА
МИНОБРНАУКИ РФ
ФГБОУ ВПО Тверской государственный технический университет
Кафедра «Программное обеспечение».


Курсовая работа.
Дисциплина «Алгоритмы и структуры данных».
Тема: «Алгоритмы поиска ошибок при передачи текста по информационному каналу».



Выполнил: студент группы
ПИН 17.05
Иванов Роман
Проверил:
Мальков А.А


Тверь 2018
Оглавление
Введение.	2
Аналитическая часть.	3
История создание кода Хэмминга.	3
Реализация кода Хэмминга	4
Подготовка.	4
Вычисление контрольных бит.	5
Декодирование и исправление ошибок.	6
Вывод.	6
Бит четности.	7
Примеры	7
Вывод.	7
Мой собственный алгоритм или алгоритм контрольной суммы.	7
Плюсы и минусы алгоритма.	8
Выводы.	9
Проектная часть.	9
Функционал	9
Архитектура приложения	9
Диаграмма классов	9
Реализация проекта	9
Тестирование	12
Заключение	12
Источники	13



Введение.
Цель: Ознакомится с алгоритмами поиска ошибок при передачи текста по информационному каналу и реализовать их.
Задача: Windows Form проект на c#. 
Реализовано: код Хэмминга, добавление бита четности, собственный алгоритм «Контрольная сумма».
Аналитическая часть.

История создание кода Хэмминга.
 Первая работа по теории кодирования была опубликована известным ученым Ричардом Уэсли Хэммингом в 1950 году. Привело его к этой работе следующее: после окончания университета он занимался тем, что сейчас бы назвали численными методами, и работал сначала в Лос-Аламосе над Манхэттенским проектом, то есть над созданием ядерной бомбы, а потом почти сразу, в 1946 году, перешел в Bell Labs. Это та великая лаборатория, в которой было сделано, наверное, самое большое количество открытий второй половины XX века. Там он продолжал заниматься численными методами, решать уравнения на первых вычислительных машинах.
Вычислительные машины были огромными, ненадежными, потому что на лампах, и для их охлаждения требовалось большое количество воды, и тем не менее они часто сбоили. Программисты того времени, чтобы бороться со сбоями, делили задачу на этапы, и после каждого этапа программа должна была записать или распечатать результаты. Тогда задачи были простенькие по теперешним понятиям, в основном счет.
Зачем это делалось? Так как эти компьютеры были ненадежными, у них было такое устройство, как сигнал тревоги. Когда работа шла неверно, когда они обнаруживали ошибку, то звучал сигнал тревоги, и работа прекращалась. Соответственно, человек мог с этого места посмотреть назад, какое было первое от этого места правильно посчитанное значение, и продолжать счет дальше. Хэмминг оставлял свою работу на выходные и уходил спокойно отдыхать, а приходя, обнаруживал, что машина работала впустую, потому что в некий момент происходила ошибка, но никого не было, его не было, чтобы остановить. Значит, все его труды пропадали даром. Тогда у него возникла совершенно естественная даже не идея, а вопрос: если машина умеет обнаруживать ошибки, почему бы не научить ее, чтобы она их исправляла?
Что пришло в голову Хэммингу? Он подумал, почему, собственно, проверять все значения? Может, одного проверочного символа недостаточно? Может быть, добавить не один, а два, три, четыре - столько, сколько понадобится, и исправлять?
Так и возник, наверное, самый известный код, так называемый (7,4) код Хемминга. 4 означает, что мы будем защищать от ошибок 4 бита информации, а 7 - что для этого мы к 4 информационным битам добавим 3 проверочных. Итого всего получается 7 бит.

Реализация кода Хэмминга
Подготовка.
Допустим, у нас есть сообщение «0100010000111101», которое необходимо передать без ошибок.
Далее нам необходимо вставить контрольные биты. Они вставляются в строго определённых местах — это позиции с номерами, равными степеням двойки. В нашем случае (при длине информационного слова в 16 бит) это будут позиции 1, 2, 4, 8, 16. Соответственно, у нас получилось 5 контрольных бит (взяты в скобки):

Было:
0100010000111101
Стало:
(0)(0)0(0)100(0)0100001(0)11101
Таким образом, длина всего сообщения увеличилась на 5 бит. До вычисления самих контрольных бит, мы присвоили им значение «0».
Вычисление контрольных бит.
Теперь необходимо вычислить значение каждого контрольного бита. Значение каждого контрольного бита зависит от значений информационных бит, но не от всех, а только от тех, которые этот контрольных бит контролирует. Для того, чтобы понять, за какие биты отвечает каждых контрольный бит необходимо понять очень простую закономерность: контрольный бит с номером N контролирует все последующие N бит через каждые N бит, начиная с позиции N.
 
Здесь знаком «X» обозначены те биты, которые контролирует контрольный бит, номер которого справа. То есть, к примеру, бит номер 12 контролируется битами с номерами 4 и 8. Ясно, что чтобы узнать какими битами контролируется бит с номером N надо просто разложить N по степеням двойки. 

Но как же вычислить значение каждого контрольного бита? Делается это очень просто: берём каждый контрольный бит и смотрим сколько среди контролируемых им битов единиц, получаем некоторое целое число и, если оно чётное, то ставим ноль, в противном случае ставим единицу. Вот и всё! Можно конечно и наоборот, если число чётное, то ставим единицу, в противном случае, ставим 0. Главное, чтобы в «кодирующей» и «декодирующей» частях алгоритм был одинаков. (Мы будем применять первый вариант).
Высчитав контрольные биты для нашего информационного слова получаем следующее: 
Было:
(0)(0)0(0)100(0)0100001(0)11101
Стало:
(1)(0)0(1)100(0)0100001(0)11101

Декодирование и исправление ошибок.
Теперь, допустим, мы получили закодированное первой частью алгоритма сообщение, но оно пришло к нас с ошибкой. К примеру мы получили такое (11-ый бит передался неправильно): 
(1)(0)0(1)100(0)01*1*0001(0)11101
Вся вторая часть алгоритма заключается в том, что необходимо заново вычислить все контрольные биты (так же как и в первой части) и сравнить их с контрольными битами, которые мы получили. Так, посчитав контрольные биты с неправильным 11-ым битом мы получим такую картину: 
(0)(1)0(1)100(1)01*1*0001(0)11101
Как мы видим, контрольные биты под номерами: 1, 2, 8 не совпадают с такими же контрольными битами, которые мы получили. Теперь просто сложив номера позиций неправильных контрольных бит (1 + 2 + 8 = 11) мы получаем позицию ошибочного бита. Теперь просто инвертировав его и отбросив контрольные биты, мы получим исходное сообщение в первозданном виде! Абсолютно аналогично поступаем со второй частью сообщения
Вывод.
С помощью кода Хэмминга мы можем не только находить ошибку но и исправлять ее.
Бит четности.
В вычислительной технике и сетях передачи данных би́том чётности называют контрольный бит, принимающий значения '0' или '1' и служащий для проверки общей чётности двоичного числа (чётностиколичества единичных битов в числе).
Примеры
Бит чётности или контрольный разряд формируется при выполнении операции «ИсключаюшееИЛИ» поразрядно.  Рассмотрим схему, использующую девятибитные кодовые слова, состоящие из восьми битданных, за которыми следует бит чётности.
Число 10111101 содержит 6 '1' битов. Бит чётности будет 0, получаем кодовое слово 101111010.
Число 01110011 содержит 5 '1' битов.
Бит чётности будет 1, получаем кодовое слово 011100111.
Число 00000000 не содержит '1' битов. Бит чётности будет 0, получаем кодовое слово 000000000.
Пустой или несуществующий поток битов также имеет ноль единичных битов, поэтому бит чётности будет 0.
Вывод.
То есть с помощью бита четности, мы можем проверить была ли совершена ошибка при передаче данных.

Мой собственный алгоритм или алгоритм контрольной суммы.
Допустим у нас есть сообщение «001», которое нам нужно передать, оно будет размешаться в некотором блоке.
 
Но за нахождение в также у блока присутствует «стоимость за нахождение в нем» , допустим блок[0] = 2 , блок [1] = 3 и так далее . Блок[i] = 2+i;
 
Но так же у элементов находящихся в блок присутствует некоторая стоимость.
У нуля это единица, у единицы это двойка.
 
И путем перемножения мы получаем «контрольную сумму» данного сообщения в данном случаи = (1*2) + (1*3) + (2*4) = 13.
Плюсы и минусы алгоритма.
  Плюсы - достаточно легкая и понятная реализация, при многократном использовании можно создать «словарь» в который записывается контрольная сумма и полученное сообщение, то есть когда в нашем словаре будет достаточно данных мы можем восстанавливать сообщение по контрольной сумме.
Минусы - непонятно как лучше отправлять контрольную либо отдельным сообщением, либо вместе с сообщением, непонятно как лучше переводить сумму в двоичную систему или оставлять в десятичной.
Выводы.
Алгоритм не достаточно хорош, но работает, да и ладно.
Проектная часть.
Функционал 
Программа определяет была ли совершена ошибка, при передаче данных.

Архитектура приложения
Программа состоит из двух частей: из Интерфейса Windows Forms и классов в которых находятся сами алгоритмы.
Диаграмма классов

  
Реализация проекта 
Интерфейс программы:
Код Хэмминга:
 
Бит четности
 
Контрольная сумма:
 
Так же в приложении присутствуют обработчики ошибок 
 
 
Среда разработки:
Microsoft Visual Studio
Инструменты:
C# + .NET

Тестирование
Для автоматического тестирования я добавил в проект UnitTestProject.
Результаты тестов:
 

Заключение
В данной курсовой работе я реализовал 3 алгоритма поиска ошибок при передаче текста, также я получил представление о том, что такое самокорректирующийся код, изучил алгоритм кодирования и декодирования кодом Хэмминга
Проект был успешно протестирован. 


Источники
Код Хэмминга    https://habr.com/post/140611/
Бит четности  https://ru.wikipedia.org/wiki/Бит_чётности
М.Н.Аршинов, Л.Е.Садовский. КОДЫ И МАТЕМАТИКА
